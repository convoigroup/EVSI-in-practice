c.amb ~ dlnorm(m.amb, tau.amb)     # Cost of ambulatory care
c.hosp ~ dlnorm(m.hosp, tau.hosp)  # Cost of hospitalization
c.death ~ dlnorm(m.death,tau.death)#Cost of death
# Effects
e.chemo ~ dbeta(p1.chemo,p2.chemo)
e.amb ~ dbeta(p1.amb,p2.amb)
e.hosp ~ dbeta(p1.hosp,p2.hosp)
}
filein <- file.path(tempdir(),fileext="datmodel.txt")
write.model(model.dat,filein)
#####################Jalal and Alarid-Escudero#####################
###Estimating n0
Size.Outer<-1000
Size.Inner<-10000
# Set the number of chains in iterations
n.chains <- 3     # Number of chains
n.burnin <- 1000  # Number of burn in iterations
n.iter <- ceiling(Size.Inner/n.chains) + n.burnin # Number of iterations per chain
X.SE1<-X.SE2<-X.N.hosp<-X.N.die<-N.amb<-N.hosp<-array(NA,dim=Size.Outer)
n<-30
T.re.amb<-T.re.hosp<-array(NA,dim=c(Size.Outer,2*n))
for(i in 1:Size.Outer){
X.SE1[i]<-rbinom(1,n,pi1[i])
X.SE2[i]<-rbinom(1,n,pi2[i])
X.N.hosp[i]<-rbinom(1,X.SE1[i]+X.SE2[i],gamma[i])
X.N.die[i]<-rbinom(1,X.N.hosp[i],gamma2[i])
N.amb[i]<-X.SE1[i]+X.SE2[i]-X.N.hosp[i]
if(N.amb[i]>0){
T.re.amb[i,1:N.amb[i]]<-rexp(N.amb[i],recover.amb[i])
}
N.hosp[i]<-X.N.hosp[i]-X.N.die[i]
if(N.hosp[i]>0){
T.re.hosp[i,1:N.hosp[i]]<-rexp(N.hosp[i],recover.hosp[i])}
}
T.re.amb<-T.re.amb[,1:max(N.amb)]
T.re.hosp<-T.re.hosp[,1:max(N.hosp)]
data.dat <- list("X.SE1","X.SE2","n",
"X.N.hosp","X.N.die",
"N.amb","T.re.amb","N.hosp","T.re.hosp","Size.Outer")
#num.se<-rep(num.se,Size.Outer)
#num.amb<-rep(num.amb,Size.Outer)
#num.death<-rep(num.death,Size.Outer)
data.full<-append(data,data.dat)
#parameters.to.save<-parameters.to.save[-c(1,2)]
#parameters.to.save<-c("pi",parameters.to.save)
# Perform the MCMC simulation with OpenBUGS.
# Close OpenBUGS once it has finished (if debug is set to TRUE)
bugs.data <- jags(
data =  data.full,
inits = NA,
parameters.to.save = parameters.to.save,
model.file = filein,
n.chains = n.chains,
n.iter = n.iter,
n.thin = 1,
n.burnin = n.burnin)
# Perform the MCMC simulation with OpenBUGS.
# Close OpenBUGS once it has finished (if debug is set to TRUE)
bugs.data <- jags(
data =  data.full,
inits = NULL,
parameters.to.save = parameters.to.save,
model.file = filein,
n.chains = n.chains,
n.iter = n.iter,
n.thin = 1,
n.burnin = n.burnin)
bugs.data$BUGSoutput$sims.list$pi
bugs.data$BUGSoutput$sims.list$gamma
Size.Outer
apply(bugs.data$BUGSoutput$sims.list$gamma,1,mean)
apply(bugs.data$BUGSoutput$sims.list$gamma,2,mean)
gamma.mean<-apply(bugs.data$BUGSoutput$sims.list$gamma,2,mean)
gamma2.mean<-apply(bugs.data$BUGSoutput$sims.list$gamma2,2,mean)
lambda.1.3.fix.mean<-apply(bugs.data$BUGSoutput$sims.list$lambda.1.3.fix,2,mean)
lambda.2.3.fix.mean<-apply(bugs.data$BUGSoutput$sims.list$lambda.2.3.fix,2,mean)
bugs.data$BUGSoutput$sims.list$SE[,,1]
bugs.data$BUGSoutput$sims.list$SE[1,,]
bugs.data$BUGSoutput$sims.list$SE[,1,]
apply(bugs.data$BUGSoutput$sims.list$SE[,1,],2,mean)
apply(bugs.data$BUGSoutput$sims.list$SE[,1,],2,median)
gamma.mean<-apply(bugs.data$BUGSoutput$sims.list$gamma,2,mean)
gamma2.mean<-apply(bugs.data$BUGSoutput$sims.list$gamma2,2,mean)
lambda.2.3.fix.mean<-apply(bugs.data$BUGSoutput$sims.list$lambda.2.3.fix,2,mean)
lambda.1.3.fix.mean<-apply(bugs.data$BUGSoutput$sims.list$lambda.1.3.fix,2,mean)
SE.mean<-apply(bugs.data$BUGSoutput$sims.list$SE,2,mean)
SE1.mean<-apply(bugs.data$BUGSoutput$sims.list$SE[,1,],2,mean)
SE2.mean<-apply(bugs.data$BUGSoutput$sims.list$SE[,2,],2,mean)
##Estimating n0 separately for each element of the meta-model
n<-30
var.theta<-apply(theta,2,var)
gamma.n0<-n*(var.theta[3]/var(gamma.mean)-1)
gamma2.n0<-n*(var.theta[4]/var(gamma2.mean)-1)
lambda2.n0<-n*(var.theta[5]/var(lambda.2.3.fix.mean)-1)
lambda1.n0<-n*(var.theta[6]/var(lambda.1.3.fix.mean)-1)
SE1.n0<-n*(var.theta[7]/var(SE1.mean)-1)
SE2.n0<-n*(var.theta[8]/var(SE2.mean)-1)
n0<-c(gamma.n0,gamma2.n0,lambda2.n0,lambda1.n0,SE1.n0,SE2.n0)
n<-rep(150,6)
llpred<-predict.ga(lmm1,n0=n0,n=n)
evsi.Jal <- mean(pmax(0,llpred))-max(mean(llpred),0)
evsi.Jal
#####################Jalal and Alarid-Escudero#####################
###Estimating n0
Size.Outer<-1000
Size.Inner<-10000
start<-Sys.time()
# Set the number of chains in iterations
n.chains <- 3     # Number of chains
n.burnin <- 1000  # Number of burn in iterations
n.iter <- ceiling(Size.Inner/n.chains) + n.burnin # Number of iterations per chain
X.SE1<-X.SE2<-X.N.hosp<-X.N.die<-N.amb<-N.hosp<-array(NA,dim=Size.Outer)
n<-30
T.re.amb<-T.re.hosp<-array(NA,dim=c(Size.Outer,2*n))
for(i in 1:Size.Outer){
X.SE1[i]<-rbinom(1,n,pi1[i])
X.SE2[i]<-rbinom(1,n,pi2[i])
X.N.hosp[i]<-rbinom(1,X.SE1[i]+X.SE2[i],gamma[i])
X.N.die[i]<-rbinom(1,X.N.hosp[i],gamma2[i])
N.amb[i]<-X.SE1[i]+X.SE2[i]-X.N.hosp[i]
if(N.amb[i]>0){
T.re.amb[i,1:N.amb[i]]<-rexp(N.amb[i],recover.amb[i])
}
N.hosp[i]<-X.N.hosp[i]-X.N.die[i]
if(N.hosp[i]>0){
T.re.hosp[i,1:N.hosp[i]]<-rexp(N.hosp[i],recover.hosp[i])}
}
T.re.amb<-T.re.amb[,1:max(N.amb)]
T.re.hosp<-T.re.hosp[,1:max(N.hosp)]
data.dat <- list("X.SE1","X.SE2","n",
"X.N.hosp","X.N.die",
"N.amb","T.re.amb","N.hosp","T.re.hosp","Size.Outer")
#num.se<-rep(num.se,Size.Outer)
#num.amb<-rep(num.amb,Size.Outer)
#num.death<-rep(num.death,Size.Outer)
data.full<-append(data,data.dat)
#parameters.to.save<-parameters.to.save[-c(1,2)]
#parameters.to.save<-c("pi",parameters.to.save)
# Perform the MCMC simulation with OpenBUGS.
# Close OpenBUGS once it has finished (if debug is set to TRUE)
bugs.data <- jags(
data =  data.full,
inits = NULL,
parameters.to.save = parameters.to.save,
model.file = filein,
n.chains = n.chains,
n.iter = n.iter,
n.thin = 1,
n.burnin = n.burnin)
gamma.mean<-apply(bugs.data$BUGSoutput$sims.list$gamma,2,mean)
gamma2.mean<-apply(bugs.data$BUGSoutput$sims.list$gamma2,2,mean)
lambda.2.3.fix.mean<-apply(bugs.data$BUGSoutput$sims.list$lambda.2.3.fix,2,mean)
lambda.1.3.fix.mean<-apply(bugs.data$BUGSoutput$sims.list$lambda.1.3.fix,2,mean)
SE.mean<-apply(bugs.data$BUGSoutput$sims.list$SE,2,mean)
SE1.mean<-apply(bugs.data$BUGSoutput$sims.list$SE[,1,],2,mean)
SE2.mean<-apply(bugs.data$BUGSoutput$sims.list$SE[,2,],2,mean)
##Estimating n0 separately for each element of the meta-model
n<-30
var.theta<-apply(theta,2,var)
#pi1.n0<-n*(var.theta[1]/var(pi1.mean)-1)
#rho.n0<-n*(var.theta[2]/var(rho.mean)-1)
gamma.n0<-n*(var.theta[3]/var(gamma.mean)-1)
gamma2.n0<-n*(var.theta[4]/var(gamma2.mean)-1)
lambda2.n0<-n*(var.theta[5]/var(lambda.2.3.fix.mean)-1)
lambda1.n0<-n*(var.theta[6]/var(lambda.1.3.fix.mean)-1)
SE1.n0<-n*(var.theta[7]/var(SE1.mean)-1)
SE2.n0<-n*(var.theta[8]/var(SE2.mean)-1)
n0<-c(gamma.n0,gamma2.n0,lambda2.n0,lambda1.n0,SE1.n0,SE2.n0)
n<-rep(150,6)
llpred<-predict.ga(lmm1,n0=n0,n=n)
evsi.Jal <- mean(pmax(0,llpred))-max(mean(llpred),0)
evsi.Jal
end<-Sys.time()
end-start
JalalChemo<- read.csv("C:/Users/anna heath/OneDrive/OneDrive - SickKids/EVSI Methods/EVSIJalalChemo.txt", sep="")
mean(JalalChemo$x)
.692425*60
lmm1<-gam(y~te(gamma,gamma2,lambda.2.3.fix,lambda.1.3.fix)+s(SE1)+s(SE2),data=theta)
evppi <- mean(pmax(0,lmm1$fitted.values))
evppi
save<-lmm1$fitted.values
plot(y,y-save)
lmm1<-gam(y~te(gamma,gamma2,lambda.2.3.fix,lambda.1.3.fix,SE1,SE2),data=theta)
lmm1<-gam(y~te(gamma,gamma2,lambda.2.3.fix,lambda.1.3.fix)+te(SE1,SE2),data=theta)
save<-lmm1$fitted.values
plot(y,y-save)
evppi <- mean(pmax(0,lmm1$fitted.values))
evppi
llpred<-predict.ga(lmm1,n0=n0,n=n)
llpred<-predict.ga(lmm1,n0=n0,n=n)
lmm1<-gam(y~s(gamma)+s(gamma2)+s(lambda.2.3.fix)+s(lambda.1.3.fix)+s(rho)+s(pi1),data=theta)
evppi <- mean(pmax(0,lmm1$fitted.values))
evppi
var.X.mat
##Across Q Values
Q<-50
var.X.mat<-array(NA,dim=Q)
n.burnin <- 200  # Number of burn in iterations
n.iter <- ceiling(Size.Tot/(Q*n.chains)) + n.burnin # Number of iterations per chain
Size.Mat<-ceiling(Size.Tot/Q)
#Quantiles
pi1.q<-sample(quantile(pi1,probs=1:Q/(Q+1)))
pi2.q<-sample(quantile(pi2,probs=1:Q/(Q+1)))
gamma.q<-sample(quantile(gamma,probs=1:Q/(Q+1)))
gamma2.q<-sample(quantile(gamma2,probs=1:Q/(Q+1)))
recover.amb.q<-sample(quantile(recover.amb,probs=1:Q/(Q+1)))
recover.hosp.q<-sample(quantile(recover.hosp,probs=1:Q/(Q+1)))
for(i in 1:Q){
##Moment Matching
#Generate Data
n<-150
X.SE1<-rbinom(1,n,pi1.q[i])
X.SE2<-rbinom(1,n,pi2.q[i])
X.N.hosp<-rbinom(1,X.SE1+X.SE2,gamma.q[i])
X.N.die<-rbinom(1,X.N.hosp,gamma2.q[i])
N.amb<-X.SE1+X.SE2-X.N.hosp
T.re.amb<-rexp(N.amb,recover.amb.q[i])
N.hosp<-X.N.hosp-X.N.die
T.re.hosp<-rexp(N.hosp,recover.hosp.q[i])
data.dat <- list("X.SE1","X.SE2","n",
"X.N.hosp","X.N.die",
"N.amb","T.re.amb","N.hosp","T.re.hosp")
data.full<-append(data,data.dat)
# Perform the MCMC simulation with OpenBUGS.
# Close OpenBUGS once it has finished (if debug is set to TRUE)
bugs.data <- jags(
data =  data.full,
inits = inits,
parameters.to.save = parameters.to.save,
model.file = filein,
n.chains = n.chains,
n.iter = n.iter,
n.thin = 1,
n.burnin = n.burnin,progress.bar = "none")
e<-matrix(NA,ncol=2,nrow=Size.Mat)
c<-matrix(NA,ncol=2,nrow=Size.Mat)
for(l in 1:Size.Mat){
e[l,]<-effects(bugs.data$BUGSoutput$sims.list[["pi1"]][l],
bugs.data$BUGSoutput$sims.list[["pi2"]][l],
bugs.data$BUGSoutput$sims.list[["SE"]][l,1],
bugs.data$BUGSoutput$sims.list[["SE"]][l,2],
bugs.data$BUGSoutput$sims.list[["lambda.1.1"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.1.2"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.1.3"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.2"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.3"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.4"]][l],
bugs.data$BUGSoutput$sims.list[["e.chemo"]][l],
bugs.data$BUGSoutput$sims.list[["e.amb"]][l],
bugs.data$BUGSoutput$sims.list[["e.hosp"]][l],
N,TH)
c[l,]<-costs(bugs.data$BUGSoutput$sims.list[["pi1"]][l],
bugs.data$BUGSoutput$sims.list[["pi2"]][l],
bugs.data$BUGSoutput$sims.list[["SE"]][l,1],
bugs.data$BUGSoutput$sims.list[["SE"]][l,2],
bugs.data$BUGSoutput$sims.list[["lambda.1.1"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.1.2"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.1.3"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.2"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.3"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.4"]][l],
c.drug,
bugs.data$BUGSoutput$sims.list[["c.amb"]][l],
bugs.data$BUGSoutput$sims.list[["c.hosp"]][l],
bugs.data$BUGSoutput$sims.list[["c.death"]][l],
N,TH)
}
rm(bugs.data)
NB.X<-wtp*e-c
rm(e,c)
var.X.mat[i]<-var(NB.X[,2]-NB.X[,1])
rm(NB.X)
}
prepost.MM<-(save-mean(save))/sd(save)*sqrt(var(NB[,2]-NB[,1])-mean(var.X.mat))+mean(save)
EVSI.calc<-mean(pmax(prepost.MM,0))-max(0,mean(prepost.MM))
rm(prepost.MM)
EVSI.calc
###Heath et al#########################
Size.Tot<-500000
Size.Dist<-50
#Model
model.dat<-function(){
X.SE1 ~ dbin(pi[1],n)
X.SE2 ~ dbin(pi[2],n)
X.N.hosp ~ dbinom(gamma,X.SE1+X.SE2)
X.N.die ~ dbin(gamma2,X.N.hosp)
#DATA - Recovery
recover.amb<--log(1-lambda.1.3.fix)
recover.hosp<--log(1-lambda.2.3.fix)
for(i in 1:N.amb){
T.re.amb[i] ~ dexp(recover.amb)}
for(i in 1:N.hosp){
T.re.hosp[i] ~ dexp(recover.hosp)}
# Side effects analysis
num.se ~ dbin(pi[1], num.pat)     # sampling distribution
pi[1] ~ dbeta(1, 1)               # prior distribution
# rho = Relative risk of hematological side effects given new treatment compared to SoC
# pi[2] = Probability of hematological side effects given new treatment
rho ~ dnorm(m.rho, tau.rho)
pi[2] <- rho * pi[1]
# Treatment of side effects analysis -  Markov Model
# gamma = probability that side effects are treated by ambulatory care
# 1- gamma = probability that side effects are treated in hospital
num.amb ~ dbin(gamma, num.se)      # sampling distribution
gamma ~ dbeta(1, 1)                # prior distribution
num.death ~ dbin(gamma2,num.se-num.amb)
gamma2 ~ dbeta(1,4)
#Recover
lambda.1.3.fix ~ dbeta(p1.1.3,p2.1.3)
lambda.2.3.fix ~ dbeta(p1.2.3,p2.2.3)
#You go to hospital
lambda.1.2<-gamma/TH
#OR you recover with high prob
lambda.1.3<-(1-lambda.1.2)*lambda.1.3.fix
#OR stay in the same state
lambda.1.1 <-(1-lambda.1.3.fix)*(1-lambda.1.2)
#Either you die
lambda.2.4<-gamma2/TH
#OR you recover with high prob
lambda.2.3<-(1-lambda.2.4)*lambda.2.3.fix
#OR you stay in the same state
lambda.2.2<-(1-lambda.2.3.fix)*(1-lambda.2.4)
# Costs
# These are sampled direct from distributions, so no prior is needed.
c.amb ~ dlnorm(m.amb, tau.amb)     # Cost of ambulatory care
c.hosp ~ dlnorm(m.hosp, tau.hosp)  # Cost of hospitalization
c.death ~ dlnorm(m.death,tau.death)#Cost of death
# Effects
e.chemo ~ dbeta(p1.chemo,p2.chemo)
e.amb ~ dbeta(p1.amb,p2.amb)
e.hosp ~ dbeta(p1.hosp,p2.hosp)
# Predictive distributions on the clinical outcomes
for (t in 1:2) {
SE[t] ~ dbin(pi[t], N)         # Expected number of patients with side effects
}
#VoI
pi1<-pi[1]
pi2<-pi[2]
}
filein <- file.path(tempdir(),fileext="datmodel.txt")
write.model(model.dat,filein)
parameters.to.save
source('~/GitHub/EVSI_Comparison/Chemotherapy/Chemotherapy Model.R')
lmm1<-gam(y~s(gamma)+s(gamma2)+s(lambda.2.3.fix)+s(lambda.1.3.fix)+s(rho)+s(pi1),data=theta)
### EVPPI estimation
y<-INB[,-d.star]
lmm1<-gam(y~s(gamma)+s(gamma2)+s(lambda.2.3.fix)+s(lambda.1.3.fix)+s(rho)+s(pi1),data=theta)
evppi <- mean(pmax(0,lmm1$fitted.values))
evppi
save<-lmm1$fitted.values
###Heath et al#########################
Size.Tot<-500000
Size.Dist<-50
#Model
model.dat<-function(){
X.SE1 ~ dbin(pi[1],n)
X.SE2 ~ dbin(pi[2],n)
X.N.hosp ~ dbinom(gamma,X.SE1+X.SE2)
X.N.die ~ dbin(gamma2,X.N.hosp)
#DATA - Recovery
recover.amb<--log(1-lambda.1.3.fix)
recover.hosp<--log(1-lambda.2.3.fix)
for(i in 1:N.amb){
T.re.amb[i] ~ dexp(recover.amb)}
for(i in 1:N.hosp){
T.re.hosp[i] ~ dexp(recover.hosp)}
# Side effects analysis
num.se ~ dbin(pi[1], num.pat)     # sampling distribution
pi[1] ~ dbeta(1, 1)               # prior distribution
# rho = Relative risk of hematological side effects given new treatment compared to SoC
# pi[2] = Probability of hematological side effects given new treatment
rho ~ dnorm(m.rho, tau.rho)
pi[2] <- rho * pi[1]
# Treatment of side effects analysis -  Markov Model
# gamma = probability that side effects are treated by ambulatory care
# 1- gamma = probability that side effects are treated in hospital
num.amb ~ dbin(gamma, num.se)      # sampling distribution
gamma ~ dbeta(1, 1)                # prior distribution
num.death ~ dbin(gamma2,num.se-num.amb)
gamma2 ~ dbeta(1,4)
#Recover
lambda.1.3.fix ~ dbeta(p1.1.3,p2.1.3)
lambda.2.3.fix ~ dbeta(p1.2.3,p2.2.3)
#You go to hospital
lambda.1.2<-gamma/TH
#OR you recover with high prob
lambda.1.3<-(1-lambda.1.2)*lambda.1.3.fix
#OR stay in the same state
lambda.1.1 <-(1-lambda.1.3.fix)*(1-lambda.1.2)
#Either you die
lambda.2.4<-gamma2/TH
#OR you recover with high prob
lambda.2.3<-(1-lambda.2.4)*lambda.2.3.fix
#OR you stay in the same state
lambda.2.2<-(1-lambda.2.3.fix)*(1-lambda.2.4)
# Costs
# These are sampled direct from distributions, so no prior is needed.
c.amb ~ dlnorm(m.amb, tau.amb)     # Cost of ambulatory care
c.hosp ~ dlnorm(m.hosp, tau.hosp)  # Cost of hospitalization
c.death ~ dlnorm(m.death,tau.death)#Cost of death
# Effects
e.chemo ~ dbeta(p1.chemo,p2.chemo)
e.amb ~ dbeta(p1.amb,p2.amb)
e.hosp ~ dbeta(p1.hosp,p2.hosp)
# Predictive distributions on the clinical outcomes
for (t in 1:2) {
SE[t] ~ dbin(pi[t], N)         # Expected number of patients with side effects
}
#VoI
pi1<-pi[1]
pi2<-pi[2]
}
filein <- file.path(tempdir(),fileext="datmodel.txt")
write.model(model.dat,filein)
#Number of Side Effects
pi1<-as.data.frame(prior.model$BUGSoutput$sims.matrix)[,"pi1"]
pi2<-as.data.frame(prior.model$BUGSoutput$sims.matrix)[,"pi2"]
#Treatment of Side Effects
gamma<-as.data.frame(prior.model$BUGSoutput$sims.matrix)[,"gamma"]
gamma2<-as.data.frame(prior.model$BUGSoutput$sims.matrix)[,"gamma2"]
recover.amb<--log(1-as.data.frame(prior.model$BUGSoutput$sims.matrix)[,"lambda.1.3.fix"])
recover.hosp<--log(1-as.data.frame(prior.model$BUGSoutput$sims.matrix)[,"lambda.2.3.fix"])
##Across Q Values
Q<-50
var.X.mat<-array(NA,dim=Q)
n.burnin <- 200  # Number of burn in iterations
n.iter <- ceiling(Size.Tot/(Q*n.chains)) + n.burnin # Number of iterations per chain
Size.Mat<-ceiling(Size.Tot/Q)
#Quantiles
pi1.q<-sample(quantile(pi1,probs=1:Q/(Q+1)))
pi2.q<-sample(quantile(pi2,probs=1:Q/(Q+1)))
gamma.q<-sample(quantile(gamma,probs=1:Q/(Q+1)))
gamma2.q<-sample(quantile(gamma2,probs=1:Q/(Q+1)))
recover.amb.q<-sample(quantile(recover.amb,probs=1:Q/(Q+1)))
recover.hosp.q<-sample(quantile(recover.hosp,probs=1:Q/(Q+1)))
for(i in 1:Q){
##Moment Matching
#Generate Data
n<-150
X.SE1<-rbinom(1,n,pi1.q[i])
X.SE2<-rbinom(1,n,pi2.q[i])
X.N.hosp<-rbinom(1,X.SE1+X.SE2,gamma.q[i])
X.N.die<-rbinom(1,X.N.hosp,gamma2.q[i])
N.amb<-X.SE1+X.SE2-X.N.hosp
T.re.amb<-rexp(N.amb,recover.amb.q[i])
N.hosp<-X.N.hosp-X.N.die
T.re.hosp<-rexp(N.hosp,recover.hosp.q[i])
data.dat <- list("X.SE1","X.SE2","n",
"X.N.hosp","X.N.die",
"N.amb","T.re.amb","N.hosp","T.re.hosp")
data.full<-append(data,data.dat)
# Perform the MCMC simulation with OpenBUGS.
# Close OpenBUGS once it has finished (if debug is set to TRUE)
bugs.data <- jags(
data =  data.full,
inits = inits,
parameters.to.save = parameters.to.save,
model.file = filein,
n.chains = n.chains,
n.iter = n.iter,
n.thin = 1,
n.burnin = n.burnin,progress.bar = "none")
e<-matrix(NA,ncol=2,nrow=Size.Mat)
c<-matrix(NA,ncol=2,nrow=Size.Mat)
for(l in 1:Size.Mat){
e[l,]<-effects(bugs.data$BUGSoutput$sims.list[["pi1"]][l],
bugs.data$BUGSoutput$sims.list[["pi2"]][l],
bugs.data$BUGSoutput$sims.list[["SE"]][l,1],
bugs.data$BUGSoutput$sims.list[["SE"]][l,2],
bugs.data$BUGSoutput$sims.list[["lambda.1.1"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.1.2"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.1.3"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.2"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.3"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.4"]][l],
bugs.data$BUGSoutput$sims.list[["e.chemo"]][l],
bugs.data$BUGSoutput$sims.list[["e.amb"]][l],
bugs.data$BUGSoutput$sims.list[["e.hosp"]][l],
N,TH)
c[l,]<-costs(bugs.data$BUGSoutput$sims.list[["pi1"]][l],
bugs.data$BUGSoutput$sims.list[["pi2"]][l],
bugs.data$BUGSoutput$sims.list[["SE"]][l,1],
bugs.data$BUGSoutput$sims.list[["SE"]][l,2],
bugs.data$BUGSoutput$sims.list[["lambda.1.1"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.1.2"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.1.3"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.2"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.3"]][l],
bugs.data$BUGSoutput$sims.list[["lambda.2.4"]][l],
c.drug,
bugs.data$BUGSoutput$sims.list[["c.amb"]][l],
bugs.data$BUGSoutput$sims.list[["c.hosp"]][l],
bugs.data$BUGSoutput$sims.list[["c.death"]][l],
N,TH)
}
rm(bugs.data)
NB.X<-wtp*e-c
rm(e,c)
var.X.mat[i]<-var(NB.X[,2]-NB.X[,1])
rm(NB.X)
}
prepost.MM<-(save-mean(save))/sd(save)*sqrt(var(NB[,2]-NB[,1])-mean(var.X.mat))+mean(save)
EVSI.calc<-mean(pmax(prepost.MM,0))-max(0,mean(prepost.MM))
rm(prepost.MM)
EVSI.calc
lmm1<-gam(y~s(gamma)+s(gamma2)+s(lambda.2.3.fix)+s(lambda.1.3.fix)+s(rho)+s(pi1),data=theta)
n0
n<-rep(150,6)
llpred<-predict.ga(lmm1,n0=n0,n=n)
evsi.Jal <- mean(pmax(0,llpred))-max(mean(llpred),0)
evsi.Jal
recover.hosp<--log(1-theta[,"lambda.2.3.fix"])
